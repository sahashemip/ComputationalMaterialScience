import unittest
import os
import sys
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt

sys.path.insert(0, '../src')

from utils import (
    get_normalized_vector,
    make_orthogonal,
    create_coordinate_system,
    rotate_material_coordinare_around_z,
    get_beam_polarization_vector,
    compute_raman,
    make_polarplot,
    write_to_file
    )


class TestLinearAlgebraFunctions(unittest.TestCase):
    """Unittests for methods in '../src/utils.py' module."""

    def test_get_normalized_vector_with_non_zero_input(self):
        """Test normalization of a non-zero vector."""
        input_array = np.array([3, 4])
        expected_output = np.array([0.6, 0.8])
        np.testing.assert_array_almost_equal(get_normalized_vector(input_array),
                                             expected_output)
    
    def test_get_normalized_vector_with_zero_input(self):
        """Test normalization of a zero vector."""
        input_array = np.array([0, 0])
        np.testing.assert_array_almost_equal(get_normalized_vector(input_array),
                               input_array)

    def test_make_orthogonal(self):
        """Test orthogonal projection is computed correctly."""
        vector1 = np.array([3, 4])
        vector2 = np.array([4, 3])
        expected_projection = vector1 - np.dot(vector1, vector2) * vector2
        np.testing.assert_array_almost_equal(make_orthogonal(vector1, vector2), expected_projection)

    def test_create_coordinate_system_normal_case(self):
        """Test that the function returns a valid coordinate system for non-parallel vectors."""
        vector1 = np.array([1, 0, 0])
        vector2 = np.array([0, 1, 0])
        expected_vector3 = np.cross(vector1, vector2)
        expected_output = np.array([vector2, expected_vector3, vector1])
        
        result = create_coordinate_system(vector1, vector2)
        np.testing.assert_array_equal(result, expected_output)

    def test_create_coordinate_system_error_for_parallel_vectors(self):
        """Test that the function raises a ValueError for parallel vectors."""
        vector1 = np.array([1, 1, 1])
        vector2 = np.array([2, 2, 2])
        
        with self.assertRaises(ValueError) as context:
            create_coordinate_system(vector1, vector2)  
        self.assertTrue('Coordinate system is not generated by parallel bases.' in str(context.exception))

    def test_create_coordinate_system_error_for_zero_vector(self):
        """Test that the function raises a ValueError when one of the vectors is a zero vector."""
        vector1 = np.array([0, 0, 0])
        vector2 = np.array([1, 0, 0])

        with self.assertRaises(ValueError) as context:
            create_coordinate_system(vector1, vector2)        
        self.assertTrue('Coordinate system is not generated by parallel bases.' in str(context.exception))

    def test_rotate_material_coordinare_around_z_single_angle(self):
        """Test rotation with a single angle."""
        alpha = np.array([np.pi / 2])
        expected_matrix = np.array([
            [[0, -1, 0],
             [1, 0, 0],
             [0, 0, 1]]
        ])
        result = rotate_material_coordinare_around_z(alpha)
        np.testing.assert_array_almost_equal(result, expected_matrix)

    def test_rotate_material_coordinare_around_z_multiple_angles(self):
        """Test rotation with multiple angles."""
        alphas = np.array([0, np.pi / 2, np.pi, 2 * np.pi])
        expected_matrices = np.array([
            [[1, 0, 0],
             [0, 1, 0],
             [0, 0, 1]],
            [[0, -1, 0],
             [1, 0, 0],
             [0, 0, 1]],
            [[-1, 0, 0],
             [0, -1, 0],
             [0, 0, 1]],
            [[1, 0, 0],
             [0, 1, 0],
             [0, 0, 1]]
        ])
        result = rotate_material_coordinare_around_z(alphas)
        np.testing.assert_array_almost_equal(result, expected_matrices)

    def test_rotate_material_coordinare_around_z_edge_cases(self):
        """Test rotation with edge case angles."""
        alphas = np.array([-2 * np.pi, 4 * np.pi])
        expected_matrices = np.array([
            [[1, 0, 0],
             [0, 1, 0],
             [0, 0, 1]],
            [[1, 0, 0],
             [0, 1, 0],
             [0, 0, 1]]
        ])
        result = rotate_material_coordinare_around_z(alphas)
        np.testing.assert_array_almost_equal(result, expected_matrices)

    def test_get_beam_polarization_vector(self):
        """Test that the function returns the correct polarization vector."""
        basis_set = np.array([
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1]
        ])
        material_coord = np.array([
            [0, -1, 0],
            [1, 0, 0],
            [0, 0, 1]
        ])
        axis = np.array([1, 0, 0])
        expected_result = np.linalg.inv(basis_set) @ material_coord @ basis_set @ axis.T
        result = get_beam_polarization_vector(basis_set, material_coord, axis)
        np.testing.assert_array_almost_equal(result, expected_result)

    def setUp(self):
        """Set up test variables for 'compute_raman'."""
        self.vector1 = np.array([[1], [0], [0]])
        self.vector2 = np.array([[0], [1], [0]])
        self.tensor = np.array([
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1]
        ])

        self.expected = 0

    def test_compute_raman_basic(self):
        """Test computing Raman activity with basic inputs."""
        result = compute_raman(self.vector1, self.tensor, self.vector2)
        self.assertEqual(result, self.expected)

    def test_compute_raman_with_non_identity_tensor(self):
        """Test with a non-identity tensor to verify non-zero Raman activity."""
        non_identity_tensor = np.array([
            [0, 1, 0],
            [1, 0, 0],
            [0, 0, 1]
        ])
        expected_non_zero = np.abs(self.vector2.T @ non_identity_tensor @ self.vector1)**2
        result = compute_raman(self.vector1, non_identity_tensor, self.vector2)
        self.assertEqual(result, expected_non_zero)

    def test_compute_raman_edge_case(self):
        """Test computing Raman activity with edge-case values."""
        zero_vector = np.array([[0], [0], [0]])
        result = compute_raman(zero_vector, self.tensor, self.vector2)
        self.assertEqual(result, 0)

    def test_make_polarplot_creates_file(self):
        """Test if the polar plot file is created."""
        angles = np.linspace(0, 2 * np.pi, 100)
        intensities = np.sin(angles)**2
        output_fig = 'test_polarplot.png'
        make_polarplot(angles, intensities, output_fig=output_fig)
        
        self.assertTrue(Path(output_fig).exists())
        
        # Remove file if created!
        if Path(output_fig).exists():
            os.remove(output_fig)

    def test_write_to_file_creates_file(self):
        """Test if the output file is created."""
        output_file = Path("test_output.txt")
        combined_array = np.array([[1, 2], [3, 4]])
        self.assertFalse(output_file.exists(), "Output file should not exist before running the test")
        write_to_file(combined_array, output_file)
        
        self.assertTrue(output_file.exists(), "Output file should be created by write_to_file function")
        
        # Remove file if created!
        if Path(output_file).exists():
            os.remove(output_file)

    def test_write_to_file_content(self):
        """Test if the output file content matches the expected output."""
        expected_content = "1\t2\n3\t4\n"
        output_file = Path("test_output.txt")
        combined_array = np.array([[1, 2], [3, 4]])
        write_to_file(combined_array, output_file)
        
        with open(output_file, 'r') as file:
            content = file.read()
            
        self.assertEqual(content, expected_content, "File content does not match the expected output")
        
        # Remove file if created!
        if Path(output_file).exists():
            os.remove(output_file)


if __name__ == '__main__':
    print('Testing utils.py module')
    unittest.main()